// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ps.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ps_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ps_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ps_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ps_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ps_2eproto;
namespace ps {
class BatchRequest;
struct BatchRequestDefaultTypeInternal;
extern BatchRequestDefaultTypeInternal _BatchRequest_default_instance_;
class BatchResponse;
struct BatchResponseDefaultTypeInternal;
extern BatchResponseDefaultTypeInternal _BatchResponse_default_instance_;
class Keys;
struct KeysDefaultTypeInternal;
extern KeysDefaultTypeInternal _Keys_default_instance_;
class SingleRequest;
struct SingleRequestDefaultTypeInternal;
extern SingleRequestDefaultTypeInternal _SingleRequest_default_instance_;
class SingleResponse;
struct SingleResponseDefaultTypeInternal;
extern SingleResponseDefaultTypeInternal _SingleResponse_default_instance_;
class Weights;
struct WeightsDefaultTypeInternal;
extern WeightsDefaultTypeInternal _Weights_default_instance_;
}  // namespace ps
PROTOBUF_NAMESPACE_OPEN
template<> ::ps::BatchRequest* Arena::CreateMaybeMessage<::ps::BatchRequest>(Arena*);
template<> ::ps::BatchResponse* Arena::CreateMaybeMessage<::ps::BatchResponse>(Arena*);
template<> ::ps::Keys* Arena::CreateMaybeMessage<::ps::Keys>(Arena*);
template<> ::ps::SingleRequest* Arena::CreateMaybeMessage<::ps::SingleRequest>(Arena*);
template<> ::ps::SingleResponse* Arena::CreateMaybeMessage<::ps::SingleResponse>(Arena*);
template<> ::ps::Weights* Arena::CreateMaybeMessage<::ps::Weights>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ps {

// ===================================================================

class Keys final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ps.Keys) */ {
 public:
  inline Keys() : Keys(nullptr) {}
  ~Keys() override;
  explicit constexpr Keys(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Keys(const Keys& from);
  Keys(Keys&& from) noexcept
    : Keys() {
    *this = ::std::move(from);
  }

  inline Keys& operator=(const Keys& from) {
    CopyFrom(from);
    return *this;
  }
  inline Keys& operator=(Keys&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Keys& default_instance() {
    return *internal_default_instance();
  }
  static inline const Keys* internal_default_instance() {
    return reinterpret_cast<const Keys*>(
               &_Keys_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Keys& a, Keys& b) {
    a.Swap(&b);
  }
  inline void Swap(Keys* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Keys* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Keys* New() const final {
    return new Keys();
  }

  Keys* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Keys>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Keys& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Keys& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Keys* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ps.Keys";
  }
  protected:
  explicit Keys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated uint64 data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_data() const;
  void _internal_add_data(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_data();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 data(int index) const;
  void set_data(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_data(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:ps.Keys)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ps_2eproto;
};
// -------------------------------------------------------------------

class Weights final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ps.Weights) */ {
 public:
  inline Weights() : Weights(nullptr) {}
  ~Weights() override;
  explicit constexpr Weights(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Weights(const Weights& from);
  Weights(Weights&& from) noexcept
    : Weights() {
    *this = ::std::move(from);
  }

  inline Weights& operator=(const Weights& from) {
    CopyFrom(from);
    return *this;
  }
  inline Weights& operator=(Weights&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Weights& default_instance() {
    return *internal_default_instance();
  }
  static inline const Weights* internal_default_instance() {
    return reinterpret_cast<const Weights*>(
               &_Weights_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Weights& a, Weights& b) {
    a.Swap(&b);
  }
  inline void Swap(Weights* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Weights* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Weights* New() const final {
    return new Weights();
  }

  Weights* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Weights>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Weights& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Weights& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Weights* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ps.Weights";
  }
  protected:
  explicit Weights(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated float data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  float _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data() const;
  void _internal_add_data(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data();
  public:
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:ps.Weights)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ps_2eproto;
};
// -------------------------------------------------------------------

class SingleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ps.SingleRequest) */ {
 public:
  inline SingleRequest() : SingleRequest(nullptr) {}
  ~SingleRequest() override;
  explicit constexpr SingleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleRequest(const SingleRequest& from);
  SingleRequest(SingleRequest&& from) noexcept
    : SingleRequest() {
    *this = ::std::move(from);
  }

  inline SingleRequest& operator=(const SingleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleRequest& operator=(SingleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleRequest* internal_default_instance() {
    return reinterpret_cast<const SingleRequest*>(
               &_SingleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SingleRequest& a, SingleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleRequest* New() const final {
    return new SingleRequest();
  }

  SingleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ps.SingleRequest";
  }
  protected:
  explicit SingleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
    kPackFieldNumber = 2,
  };
  // .ps.Keys keys = 1;
  bool has_keys() const;
  private:
  bool _internal_has_keys() const;
  public:
  void clear_keys();
  const ::ps::Keys& keys() const;
  PROTOBUF_MUST_USE_RESULT ::ps::Keys* release_keys();
  ::ps::Keys* mutable_keys();
  void set_allocated_keys(::ps::Keys* keys);
  private:
  const ::ps::Keys& _internal_keys() const;
  ::ps::Keys* _internal_mutable_keys();
  public:
  void unsafe_arena_set_allocated_keys(
      ::ps::Keys* keys);
  ::ps::Keys* unsafe_arena_release_keys();

  // bool pack = 2;
  void clear_pack();
  bool pack() const;
  void set_pack(bool value);
  private:
  bool _internal_pack() const;
  void _internal_set_pack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ps.SingleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ps::Keys* keys_;
  bool pack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ps_2eproto;
};
// -------------------------------------------------------------------

class BatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ps.BatchRequest) */ {
 public:
  inline BatchRequest() : BatchRequest(nullptr) {}
  ~BatchRequest() override;
  explicit constexpr BatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchRequest(const BatchRequest& from);
  BatchRequest(BatchRequest&& from) noexcept
    : BatchRequest() {
    *this = ::std::move(from);
  }

  inline BatchRequest& operator=(const BatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchRequest& operator=(BatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchRequest* internal_default_instance() {
    return reinterpret_cast<const BatchRequest*>(
               &_BatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BatchRequest& a, BatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchRequest* New() const final {
    return new BatchRequest();
  }

  BatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ps.BatchRequest";
  }
  protected:
  explicit BatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
    kPackFieldNumber = 2,
  };
  // repeated .ps.Keys keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::ps::Keys* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ps::Keys >*
      mutable_keys();
  private:
  const ::ps::Keys& _internal_keys(int index) const;
  ::ps::Keys* _internal_add_keys();
  public:
  const ::ps::Keys& keys(int index) const;
  ::ps::Keys* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ps::Keys >&
      keys() const;

  // bool pack = 2;
  void clear_pack();
  bool pack() const;
  void set_pack(bool value);
  private:
  bool _internal_pack() const;
  void _internal_set_pack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ps.BatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ps::Keys > keys_;
  bool pack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ps_2eproto;
};
// -------------------------------------------------------------------

class SingleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ps.SingleResponse) */ {
 public:
  inline SingleResponse() : SingleResponse(nullptr) {}
  ~SingleResponse() override;
  explicit constexpr SingleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleResponse(const SingleResponse& from);
  SingleResponse(SingleResponse&& from) noexcept
    : SingleResponse() {
    *this = ::std::move(from);
  }

  inline SingleResponse& operator=(const SingleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleResponse& operator=(SingleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleResponse* internal_default_instance() {
    return reinterpret_cast<const SingleResponse*>(
               &_SingleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SingleResponse& a, SingleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleResponse* New() const final {
    return new SingleResponse();
  }

  SingleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ps.SingleResponse";
  }
  protected:
  explicit SingleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightsFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // .ps.Weights weights = 2;
  bool has_weights() const;
  private:
  bool _internal_has_weights() const;
  public:
  void clear_weights();
  const ::ps::Weights& weights() const;
  PROTOBUF_MUST_USE_RESULT ::ps::Weights* release_weights();
  ::ps::Weights* mutable_weights();
  void set_allocated_weights(::ps::Weights* weights);
  private:
  const ::ps::Weights& _internal_weights() const;
  ::ps::Weights* _internal_mutable_weights();
  public:
  void unsafe_arena_set_allocated_weights(
      ::ps::Weights* weights);
  ::ps::Weights* unsafe_arena_release_weights();

  // int32 status = 1;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ps.SingleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ps::Weights* weights_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ps_2eproto;
};
// -------------------------------------------------------------------

class BatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ps.BatchResponse) */ {
 public:
  inline BatchResponse() : BatchResponse(nullptr) {}
  ~BatchResponse() override;
  explicit constexpr BatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchResponse(const BatchResponse& from);
  BatchResponse(BatchResponse&& from) noexcept
    : BatchResponse() {
    *this = ::std::move(from);
  }

  inline BatchResponse& operator=(const BatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchResponse& operator=(BatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchResponse* internal_default_instance() {
    return reinterpret_cast<const BatchResponse*>(
               &_BatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BatchResponse& a, BatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchResponse* New() const final {
    return new BatchResponse();
  }

  BatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ps.BatchResponse";
  }
  protected:
  explicit BatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightsFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated .ps.Weights weights = 2;
  int weights_size() const;
  private:
  int _internal_weights_size() const;
  public:
  void clear_weights();
  ::ps::Weights* mutable_weights(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ps::Weights >*
      mutable_weights();
  private:
  const ::ps::Weights& _internal_weights(int index) const;
  ::ps::Weights* _internal_add_weights();
  public:
  const ::ps::Weights& weights(int index) const;
  ::ps::Weights* add_weights();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ps::Weights >&
      weights() const;

  // int32 status = 1;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ps.BatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ps::Weights > weights_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ps_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Keys

// repeated uint64 data = 1;
inline int Keys::_internal_data_size() const {
  return data_.size();
}
inline int Keys::data_size() const {
  return _internal_data_size();
}
inline void Keys::clear_data() {
  data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Keys::_internal_data(int index) const {
  return data_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Keys::data(int index) const {
  // @@protoc_insertion_point(field_get:ps.Keys.data)
  return _internal_data(index);
}
inline void Keys::set_data(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:ps.Keys.data)
}
inline void Keys::_internal_add_data(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  data_.Add(value);
}
inline void Keys::add_data(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:ps.Keys.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
Keys::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
Keys::data() const {
  // @@protoc_insertion_point(field_list:ps.Keys.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
Keys::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
Keys::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:ps.Keys.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Weights

// repeated float data = 1;
inline int Weights::_internal_data_size() const {
  return data_.size();
}
inline int Weights::data_size() const {
  return _internal_data_size();
}
inline void Weights::clear_data() {
  data_.Clear();
}
inline float Weights::_internal_data(int index) const {
  return data_.Get(index);
}
inline float Weights::data(int index) const {
  // @@protoc_insertion_point(field_get:ps.Weights.data)
  return _internal_data(index);
}
inline void Weights::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:ps.Weights.data)
}
inline void Weights::_internal_add_data(float value) {
  data_.Add(value);
}
inline void Weights::add_data(float value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:ps.Weights.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Weights::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Weights::data() const {
  // @@protoc_insertion_point(field_list:ps.Weights.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Weights::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Weights::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:ps.Weights.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// SingleRequest

// .ps.Keys keys = 1;
inline bool SingleRequest::_internal_has_keys() const {
  return this != internal_default_instance() && keys_ != nullptr;
}
inline bool SingleRequest::has_keys() const {
  return _internal_has_keys();
}
inline void SingleRequest::clear_keys() {
  if (GetArenaForAllocation() == nullptr && keys_ != nullptr) {
    delete keys_;
  }
  keys_ = nullptr;
}
inline const ::ps::Keys& SingleRequest::_internal_keys() const {
  const ::ps::Keys* p = keys_;
  return p != nullptr ? *p : reinterpret_cast<const ::ps::Keys&>(
      ::ps::_Keys_default_instance_);
}
inline const ::ps::Keys& SingleRequest::keys() const {
  // @@protoc_insertion_point(field_get:ps.SingleRequest.keys)
  return _internal_keys();
}
inline void SingleRequest::unsafe_arena_set_allocated_keys(
    ::ps::Keys* keys) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(keys_);
  }
  keys_ = keys;
  if (keys) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ps.SingleRequest.keys)
}
inline ::ps::Keys* SingleRequest::release_keys() {
  
  ::ps::Keys* temp = keys_;
  keys_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ps::Keys* SingleRequest::unsafe_arena_release_keys() {
  // @@protoc_insertion_point(field_release:ps.SingleRequest.keys)
  
  ::ps::Keys* temp = keys_;
  keys_ = nullptr;
  return temp;
}
inline ::ps::Keys* SingleRequest::_internal_mutable_keys() {
  
  if (keys_ == nullptr) {
    auto* p = CreateMaybeMessage<::ps::Keys>(GetArenaForAllocation());
    keys_ = p;
  }
  return keys_;
}
inline ::ps::Keys* SingleRequest::mutable_keys() {
  ::ps::Keys* _msg = _internal_mutable_keys();
  // @@protoc_insertion_point(field_mutable:ps.SingleRequest.keys)
  return _msg;
}
inline void SingleRequest::set_allocated_keys(::ps::Keys* keys) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete keys_;
  }
  if (keys) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ps::Keys>::GetOwningArena(keys);
    if (message_arena != submessage_arena) {
      keys = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keys, submessage_arena);
    }
    
  } else {
    
  }
  keys_ = keys;
  // @@protoc_insertion_point(field_set_allocated:ps.SingleRequest.keys)
}

// bool pack = 2;
inline void SingleRequest::clear_pack() {
  pack_ = false;
}
inline bool SingleRequest::_internal_pack() const {
  return pack_;
}
inline bool SingleRequest::pack() const {
  // @@protoc_insertion_point(field_get:ps.SingleRequest.pack)
  return _internal_pack();
}
inline void SingleRequest::_internal_set_pack(bool value) {
  
  pack_ = value;
}
inline void SingleRequest::set_pack(bool value) {
  _internal_set_pack(value);
  // @@protoc_insertion_point(field_set:ps.SingleRequest.pack)
}

// -------------------------------------------------------------------

// BatchRequest

// repeated .ps.Keys keys = 1;
inline int BatchRequest::_internal_keys_size() const {
  return keys_.size();
}
inline int BatchRequest::keys_size() const {
  return _internal_keys_size();
}
inline void BatchRequest::clear_keys() {
  keys_.Clear();
}
inline ::ps::Keys* BatchRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:ps.BatchRequest.keys)
  return keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ps::Keys >*
BatchRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:ps.BatchRequest.keys)
  return &keys_;
}
inline const ::ps::Keys& BatchRequest::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const ::ps::Keys& BatchRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:ps.BatchRequest.keys)
  return _internal_keys(index);
}
inline ::ps::Keys* BatchRequest::_internal_add_keys() {
  return keys_.Add();
}
inline ::ps::Keys* BatchRequest::add_keys() {
  ::ps::Keys* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:ps.BatchRequest.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ps::Keys >&
BatchRequest::keys() const {
  // @@protoc_insertion_point(field_list:ps.BatchRequest.keys)
  return keys_;
}

// bool pack = 2;
inline void BatchRequest::clear_pack() {
  pack_ = false;
}
inline bool BatchRequest::_internal_pack() const {
  return pack_;
}
inline bool BatchRequest::pack() const {
  // @@protoc_insertion_point(field_get:ps.BatchRequest.pack)
  return _internal_pack();
}
inline void BatchRequest::_internal_set_pack(bool value) {
  
  pack_ = value;
}
inline void BatchRequest::set_pack(bool value) {
  _internal_set_pack(value);
  // @@protoc_insertion_point(field_set:ps.BatchRequest.pack)
}

// -------------------------------------------------------------------

// SingleResponse

// int32 status = 1;
inline void SingleResponse::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleResponse::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleResponse::status() const {
  // @@protoc_insertion_point(field_get:ps.SingleResponse.status)
  return _internal_status();
}
inline void SingleResponse::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void SingleResponse::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ps.SingleResponse.status)
}

// .ps.Weights weights = 2;
inline bool SingleResponse::_internal_has_weights() const {
  return this != internal_default_instance() && weights_ != nullptr;
}
inline bool SingleResponse::has_weights() const {
  return _internal_has_weights();
}
inline void SingleResponse::clear_weights() {
  if (GetArenaForAllocation() == nullptr && weights_ != nullptr) {
    delete weights_;
  }
  weights_ = nullptr;
}
inline const ::ps::Weights& SingleResponse::_internal_weights() const {
  const ::ps::Weights* p = weights_;
  return p != nullptr ? *p : reinterpret_cast<const ::ps::Weights&>(
      ::ps::_Weights_default_instance_);
}
inline const ::ps::Weights& SingleResponse::weights() const {
  // @@protoc_insertion_point(field_get:ps.SingleResponse.weights)
  return _internal_weights();
}
inline void SingleResponse::unsafe_arena_set_allocated_weights(
    ::ps::Weights* weights) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weights_);
  }
  weights_ = weights;
  if (weights) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ps.SingleResponse.weights)
}
inline ::ps::Weights* SingleResponse::release_weights() {
  
  ::ps::Weights* temp = weights_;
  weights_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ps::Weights* SingleResponse::unsafe_arena_release_weights() {
  // @@protoc_insertion_point(field_release:ps.SingleResponse.weights)
  
  ::ps::Weights* temp = weights_;
  weights_ = nullptr;
  return temp;
}
inline ::ps::Weights* SingleResponse::_internal_mutable_weights() {
  
  if (weights_ == nullptr) {
    auto* p = CreateMaybeMessage<::ps::Weights>(GetArenaForAllocation());
    weights_ = p;
  }
  return weights_;
}
inline ::ps::Weights* SingleResponse::mutable_weights() {
  ::ps::Weights* _msg = _internal_mutable_weights();
  // @@protoc_insertion_point(field_mutable:ps.SingleResponse.weights)
  return _msg;
}
inline void SingleResponse::set_allocated_weights(::ps::Weights* weights) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete weights_;
  }
  if (weights) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ps::Weights>::GetOwningArena(weights);
    if (message_arena != submessage_arena) {
      weights = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, weights, submessage_arena);
    }
    
  } else {
    
  }
  weights_ = weights;
  // @@protoc_insertion_point(field_set_allocated:ps.SingleResponse.weights)
}

// -------------------------------------------------------------------

// BatchResponse

// int32 status = 1;
inline void BatchResponse::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatchResponse::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatchResponse::status() const {
  // @@protoc_insertion_point(field_get:ps.BatchResponse.status)
  return _internal_status();
}
inline void BatchResponse::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void BatchResponse::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ps.BatchResponse.status)
}

// repeated .ps.Weights weights = 2;
inline int BatchResponse::_internal_weights_size() const {
  return weights_.size();
}
inline int BatchResponse::weights_size() const {
  return _internal_weights_size();
}
inline void BatchResponse::clear_weights() {
  weights_.Clear();
}
inline ::ps::Weights* BatchResponse::mutable_weights(int index) {
  // @@protoc_insertion_point(field_mutable:ps.BatchResponse.weights)
  return weights_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ps::Weights >*
BatchResponse::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:ps.BatchResponse.weights)
  return &weights_;
}
inline const ::ps::Weights& BatchResponse::_internal_weights(int index) const {
  return weights_.Get(index);
}
inline const ::ps::Weights& BatchResponse::weights(int index) const {
  // @@protoc_insertion_point(field_get:ps.BatchResponse.weights)
  return _internal_weights(index);
}
inline ::ps::Weights* BatchResponse::_internal_add_weights() {
  return weights_.Add();
}
inline ::ps::Weights* BatchResponse::add_weights() {
  ::ps::Weights* _add = _internal_add_weights();
  // @@protoc_insertion_point(field_add:ps.BatchResponse.weights)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ps::Weights >&
BatchResponse::weights() const {
  // @@protoc_insertion_point(field_list:ps.BatchResponse.weights)
  return weights_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ps

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ps_2eproto
